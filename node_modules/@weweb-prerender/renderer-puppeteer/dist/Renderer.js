"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promise_limit_1 = __importDefault(require("promise-limit"));
const puppeteer_1 = __importDefault(require("puppeteer"));
const Options_1 = require("./Options");
const waitForRender_1 = require("./waitForRender");
const schema_utils_1 = require("schema-utils");
const ts_deepmerge_1 = __importDefault(require("ts-deepmerge"));
class PuppeteerRenderer {
    constructor(options = {}) {
        this.screenSizes = {
            default: {
                order: 0,
                icon: "move",
                query: null,
                queryCss: "(min-width: 992px)",
                defaultWidth: null,
                defaultHeight: null,
                prerenderWidth: 1920,
                prerenderHeight: 1080,
            },
            tablet: {
                order: 1,
                icon: "tablet",
                query: "max-width: 991px",
                queryCss: "(min-width: 768px) and (max-width: 991px)",
                defaultWidth: 770,
                defaultHeight: (770 * 14) / 9,
                prerenderWidth: 991,
                prerenderHeight: Math.round((991 * 14) / 9),
            },
            mobile: {
                order: 2,
                icon: "mobile",
                query: "max-width: 767px",
                queryCss: "(max-width: 767px)",
                defaultWidth: 400,
                defaultHeight: (400 * 13) / 9,
                prerenderWidth: 767,
                prerenderHeight: Math.round((767 * 13) / 9),
            },
        };
        (0, schema_utils_1.validate)(Options_1.schema, options, {
            name: "Renderer Puppeteer",
            baseDataPath: "options",
        });
        this.options = (0, ts_deepmerge_1.default)(Options_1.defaultOptions, options);
        if (options.renderAfterTime &&
            this.options.timeout < options.renderAfterTime) {
            this.options.timeout = options.renderAfterTime + 1000;
        }
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // Workaround for Linux SUID Sandbox issues.
            if (process.platform === "linux") {
                if (!this.options.args)
                    this.options.args = [];
                if (this.options.args.indexOf("--no-sandbox") === -1) {
                    this.options.args.push("--no-sandbox");
                    this.options.args.push("--disable-setuid-sandbox");
                }
            }
            // Puppeteer tends to stay alive if the program exits unexpectedly, try to handle this and cleanup
            const cleanup = () => void this.destroy();
            process.on("SIGTERM", cleanup);
            process.on("SIGINT", cleanup);
            process.on("uncaughtException", cleanup);
            // Previously the whole option object was passed to `launch` which was not the best idea
            // We do a bit of backward compatibility here
            // TODO use an explicit list of legacyOptions rather than excluding the list of existing options
            /* eslint-disable @typescript-eslint/no-unused-vars */
            const _a = this.options, { maxConcurrentRoutes, inject, injectProperty, timeout, args, headless, pageSetup, pageHandler, consoleHandler, viewport, navigationOptions, launchOptions, renderAfterTime, renderAfterElementExists, elementHidden, elementVisible, skipThirdPartyRequests, renderAfterDocumentEvent } = _a, legacyOptions = __rest(_a, ["maxConcurrentRoutes", "inject", "injectProperty", "timeout", "args", "headless", "pageSetup", "pageHandler", "consoleHandler", "viewport", "navigationOptions", "launchOptions", "renderAfterTime", "renderAfterElementExists", "elementHidden", "elementVisible", "skipThirdPartyRequests", "renderAfterDocumentEvent"]);
            /* eslint-enable */
            if (!launchOptions) {
                if (Object.keys(legacyOptions).length > 1) {
                    console.warn('You are passing options to puppeteer launch using root options, which has been deprecated put them in "launchOptions" instead [Affected: ' +
                        Object.keys(legacyOptions).join(",") +
                        "]");
                }
            }
            this.puppeteer = yield puppeteer_1.default.launch(Object.assign({ headless: headless ? "new" : false, args }, (launchOptions || legacyOptions)));
        });
    }
    handleRequestInterception(page, baseURL) {
        return __awaiter(this, void 0, void 0, function* () {
            yield page.setRequestInterception(true);
            page.on("request", (req) => {
                // Skip third party requests if needed.
                if (this.options.skipThirdPartyRequests) {
                    if (!req.url().startsWith(baseURL)) {
                        void req.abort();
                        return;
                    }
                }
                void req.continue();
            });
        });
    }
    renderRoutes(routes, prerenderer) {
        const rootOptions = prerenderer.getOptions();
        const baseURL = `http://${rootOptions.server.host}:${rootOptions.server.port}`;
        const limiter = (0, promise_limit_1.default)(this.options.maxConcurrentRoutes);
        return Promise.all(routes.map((route) => limiter(() => this.getPageContent(baseURL, route))));
    }
    getPageContent(baseURL, route) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.options;
            const page = yield this.puppeteer.newPage();
            try {
                if (options.consoleHandler) {
                    const handler = options.consoleHandler;
                    page.on("console", (message) => handler(route, message));
                }
                if (options.inject) {
                    yield page.evaluateOnNewDocument(`(function () { window['${options.injectProperty}'] = ${JSON.stringify(options.inject)}; })();`);
                }
                // Allow setting viewport widths and such.
                if (options.viewport)
                    yield page.setViewport(options.viewport);
                this.orderedScreenSizes = Object.keys(this.screenSizes)
                    .map((screenSize) => ({
                    order: this.screenSizes[screenSize].order,
                    screenSize,
                }))
                    .sort(({ order: orderA }, { order: orderB }) => orderA - orderB)
                    .map(({ screenSize }) => screenSize);
                yield this.handleRequestInterception(page, baseURL);
                options.pageSetup && (yield options.pageSetup(page, route));
                // Hack just in-case the document event fires before our main listener is added.
                if (options.renderAfterDocumentEvent) {
                    yield page.evaluateOnNewDocument(waitForRender_1.listenForRender, options);
                }
                const navigationOptions = Object.assign({ waituntil: "networkidle0", timeout: 0 }, options.navigationOptions);
                page.on("pageerror", ({ message }) => console.log(`[JS_ERROR_ON_ROUTE] ${route} [MESSAGE] ${message} [/JS_ERROR_ON_ROUTE]`));
                console.log(`\nRoute started : ${route}`);
                const timeStart = Date.now();
                yield page.goto(`${baseURL}${route}`, navigationOptions);
                options.pageHandler && (yield options.pageHandler(page, route));
                const prs = [];
                // Wait options.timeout sec max
                prs.push(new Promise((resolve) => {
                    setTimeout(resolve, options.timeout);
                }));
                prs.push(this.runPrerenderProcess(page, route));
                prs.push(page.evaluate(waitForRender_1.waitForRender, options));
                const res = yield Promise.race(prs);
                if (res) {
                    throw new Error(res);
                }
                yield page.bringToFront();
                const content = yield page.content();
                const isHomePage = yield page.evaluate('wwLib.$store.getters["websiteData/getPageId"] === wwLib.$store.getters["websiteData/getDesignInfo"].homePageId');
                let screenShot;
                if (isHomePage) {
                    // Leave 10sec to the screenshot to be taken
                    const screenShotPromise = page.screenshot();
                    const timeoutPromise = new Promise((resolve) => {
                        console.log("Screenshot timed out");
                        setTimeout(resolve, 10000);
                    });
                    screenShot = yield Promise.race([screenShotPromise, timeoutPromise]);
                }
                console.log(`\nRoute done : ${route} - ${(Date.now() - timeStart) / 1000}s`);
                const result = {
                    originalRoute: route,
                    route: (yield page.evaluate("window.location.pathname")),
                    html: content,
                    screenShot,
                };
                return result;
            }
            finally {
                yield page.close();
            }
        });
    }
    resizeViewport(screenSize, page) {
        return __awaiter(this, void 0, void 0, function* () {
            yield page.setViewport({
                width: screenSize.prerenderWidth,
                height: screenSize.prerenderHeight,
            });
            yield page.bringToFront();
        });
    }
    runPrerenderProcess(page, route) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const screenSize of this.orderedScreenSizes) {
                console.log(`\nRoute ${route} - ${screenSize} started`);
                yield this.resizeViewport(this.screenSizes[screenSize], page);
                yield page.evaluate(`window.prerenderProcess.start('${screenSize}')`);
                yield page.waitForSelector(`style[generated-css="${screenSize}"]`);
                console.log(`\nRoute ${route} - ${screenSize} done`);
            }
            yield this.resizeViewport(this.screenSizes.default, page);
            yield page.evaluate("window.prerenderProcess.finalize()");
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.puppeteer) {
                yield this.puppeteer.close();
            }
        });
    }
}
exports.default = PuppeteerRenderer;
